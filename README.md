# Сервис аутентификации пользователей в рамках системы кинотеатра

Сервис предназначен для того, чтобы идентифицировать, авторизовать и аутентифицировать цифрового пользователя системы
кинотеатра.
Сервис является единственной точкой входа для пользователей системы (за исключением администраторов).

# Используемые библиотеки

Версия python 3.10

- ORM: `SQLAlchemy`
- http: `Flask`
- БД: `Postgres`
- InMemory БД: `Redis`
- валидация: `Pydantic`?
- документация: `Swagger`

## Верхнеуровневое взаимодействие компонентов
`Flask` - точка входа в приложение (т.е. взаимодействие со всеми остальными компонентами происходит через него).

`Postgres` - хранилище данных (содержит информацию о пользователях, ролях и разрешениях у ролей).

`Redis` - является хранилищем для JWT-токенов, а также кэшем для информации пользователях.


# Структура проекта

В проекте определена структура для хранения файлов

Всё что находится в корне, за пределами `/app`, относится к запуску приложения, тестам и прочему

- `/app` - корневая директория для проекта
    - `/core` - базовые файлы, необходимые для работы проекта, *в идеале сюда не добавляются файлы*
        - `config.py` - используемые переменные среды + доп параметры для конфигурации запуска
        - `constants.py` - константы, используемые в проекте
        - `permissions.py` - перечень разрешений
    - `/internal` - директория для хранения бизнес логики проекта
    - `/models` - директория для хранения `sqlalchemy` моделей **разделяется по директориям в соответствии со
      схемами в БД**
    - `/routes` - endpoint'ы проекта
    - `/schemas` - схемы данных для endpoint'ов
    - `/utils` - различные утилиты проекта
    - `main.py` основная точка входа и файл для запуска проекта
- `/tests` - тесты для проекта
    - `/unit` юнит тесты
    - `/integration` интеграционные тесты
    - `/endpoint` эндпоинт тесты


# Ошибки и HTTP статусы

Для обозначения внештатных ситуаций сервиса используются HTTP статусы. В целом, следующая спецификация
соответствует HTTP спецификации, просто здесь присутствует некоторая поправка на то, что это RESTlike сервис.

- `200` Штатный код для успешной операции
- `201` Сущность создана (`POST` запросы с созданием нового элемента)
- `400` Ошибка бизнес логики (всё что связано с конкретной логикой сущности)
- `401` Ошибка авторизации (пользователь не авторизован, токен истёк)
- `404` Объект не найден в базе данных
- `409` Проблема уникальности (подобная сущность уже существует)
- `422` Ошибка валидации
- `403` Нет прав (у пользователя недостаточно прав в системе)
- `500` Внутренняя ошибка сервиса (**вручную не кидать**)
- `410` Срок действия доступа к ресурсу истёк. (Например, какой-нибудь системный токен)

# Schemas или pydantic модели

Для выдачи и входящей обработки сущностей используются модели, представляющие описание формата
данных.

**Все модели обязательно наследуются от ** `/app/schemas/core/Model`. Там содержатся базовые
настройки

Для упрощения жизни предлагается следующая иерархия для схем данных:

- `<EntityName>Short` - содержит минимальный набор описывающий полей (обычно это id, название)
- `<EntityName>Update` - набор параметров для обновления данных в сущности
- `<EntityName>Create(Update)` - набор параметров для создания сущности
- `<EntityName>Bare(Create)` - набор полей для выдачи объекта (bare – т.е. без вложенных сущностей)
- `<EntityName>Full(Bare)` – набор полей со всеми вложенными сущностями, максимальный набор параметров
- `<EntityName>List(ListModel)` – список из объектов с любым вариантом сущности внутри

Структура не на все случаи жизни (в исключительных ситуациях можно не наследовать модели в предложенном
порядке), но крайне рекомендуется соблюдать (**особенно не следует плодить кучу моделей для одной сущности**)

## Выдача списков

Для выдачи списков объектов **обязательно использовать `/app/schemas/core/ListSchema` и наследовать,
указывая для поля `data` список со своей конкретной сущностью

# База данных и миграции

Для актуализации версии базы данных используются миграции. Используемый инструмент для осуществления миграций
– `alembic`.

Т.к. `alembic` базируется на sqlalchemy, то он умеет отслеживать изменения в `sqlalchemy` моделях.

## Создание миграции

Чтобы создать запись об изменении структуры базы данных, необходимо создать миграцию.

**Миграция (файл миграции)** – файл, содержащий 2 функции, `upgrade` и `downgrage`

`upgrade` отвечает за применение изменений к базе данных, а `downgrade` за их отмену.

Важно, чтобы обе части миграции работали корректно, это можно проверить, применив и отменив миграцию, т.е.
последовательно выполнить команды `alembic upgrade head` и `alembic downgrade -1` (**крайне рекомендуется
делать на локальной копии БД**).

### Ручное создание миграции

Чтобы создать файл миграции, необходимо выполнить команду `alembic revision -m"<название миграции>"`. После
выполнения команды будет создан пустой файл для миграции, который вы можете заполнить. Допускается, как
выполнение команд, предоставляемых `alembic`, так и написание sql команд

Вот пример файла миграции, который может у вас получиться

```python
# revision identifiers, used by Alembic.
revision = '98d57a362868'
down_revision = '311f3c2a1503'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column(
        'templates', sa.Column(
            'is_internal', sa.BOOLEAN(), server_default='false', nullable=True,
            comment='Является ли шаблон служебным и недоступным для удаления'
        )
    )
    # ### end Alembic commands ###
    op.execute("DELETE FROM notification_params WHERE template_id=1")
    op.execute("DELETE FROM templates WHERE id=1")
    op.execute(
        "INSERT INTO templates (id,name, content, created_at, created_by, content_title,is_internal) "
        "VALUES (1,'Уведомление экспертов о назначении','Вы были назначены на проект {{ project_name }} в качестве эксперта',"
        "now(),1,'Уведомление о назначении',true)"
    )

    op.execute(
        "INSERT INTO status_transition_functions (id, name, description) "
        "VALUES (12,'разослать уведомление экспертам','уведомление о назначении экспертов на проект')"
    )


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('templates', 'is_internal')
    # ### end Alembic commands ###
    op.execute("DELETE FROM notification_params WHERE template_id=1")
    op.execute("DELETE FROM templates WHERE id=1")

    op.execute('DELETE FROM status_transition_functions WHERE id=12')

```

Как можно заметить, для своих команд `alembic` использует sqlalchemy объекты, но допускается и выполнение
обычных `sql` команд.

Также, стоит обратить внимание, на строчки

```python
revision = '98d57a362868'
down_revision = '311f3c2a1503'
```

Это идентификаторы текущей версии и версии, после которой идёт созданная вами миграция. По этим
идентификаторам будет выстраиваться порядок применения миграций к базе данных. Также, в БД всегда хранится
идентификатор актуальной версии миграций (таблица `alembic_version`)

### Автоматическое создание миграций

Миграции сильно упрощают жизнь в поддержке проекта, однако очевидно, что миграции не упрощают жизнь вам, как
разработчику (и upgrade напиши и downgrade сделай и проверь, чтобы ничего не ломалось)

К счастью, есть способ сильно упростить себе жизнь.

Миграции пишутся **после** того, как вы переопределили свои `sqlalchemy` модели и зачастую их дублируют. Чтобы
не писать всё ещё раз, но уже в миграциях, существует возможность автогенерации изменений. `alembic` сам
сравнит схему данных из ваших моделей и текущую схему в бд, создав миграцию с необходимым списком изменений.

Всё что нужно для этого, так это добавить флаг к команде
создания  `alembic revision -m"<название миграции>" --autogenrate`.

Ииии.... собственно всё. В вашем файле автоматически будут созданы команды для актуализации БД к описанию
моделей. **НО ЕСТЬ НЮАНСЫ.** Автогенерация – **не идеальна**, поэтому созданные миграции необходимо **всегда
проверять на корректность**, ну и в случае необходимости править ручками

### Генерация data миграций

Если вы хотите добавить или удалить значения в базе данных (те, без которых приложение эксплуатировать
невозможно), то их **нужно создавать особым образом**.

Для миграций данных предусмотрена отдельная директория `/data_versions`, находящая в директории с
миграциями `/versions`.

Чтобы создать такую миграцию, достаточно добавить флаг при создании основной миграции,
например `alembic -x data_migration=True revision -m "add new column"`. После выполнения такой команды, помимо
основного файла миграции, будет создан дополнительный файл, в котором вы можете вписать свои миграции для
данных.

Такая миграция может выглядеть следующим образом

```python
data: Tuple[DataMigration, ...] = (
    GeneratingMigration(
        'general.roles', [
            {
                'id': 1,
                'name': "суперадминистратор",
                'description': 'пользователь, обладающий абсолютными привилегиями в системе',

                'created_at': datetime.datetime.utcnow(),
                'updated_at': datetime.datetime.utcnow()
            },
            {
                'id': 2,
                'name': 'оператор',
                'description': 'внутренний пользователь, обладающий большей частью прав, необходимых для работы в рамках системы',
                'created_at': datetime.datetime.utcnow(),
                'updated_at': datetime.datetime.utcnow()
            }
        ]
    ),
)


def data_upgrade(op):
    connection: sa.engine.Connection = op.get_bind()
    for value_set in data:
        value_set.insert(connection)


def data_downgrade(op):
    connection: sa.engine.Connection = op.get_bind()
    for value_set in data:
        value_set.delete(connection)
```

В данном примере мы не меняли содержимое функций `data_upgrade` и `data_downgrade`, однако, при необходимости
это можно сделать. Код по умолчанию, выполняет создание и удаление перечисленных объектов для указанной
таблицы. Т.к. переменная `data` представляет собой кортеж, вы можете указать несколько таких таблиц.

По умолчанию, файл миграции данных создаётся, **но никоим образом не используется в основном файле миграции**.
Если вы хотите применить изменения для данных, то вам необходимо импортировать функции `data_upgrade`
и `data_downgrade` в вашу основную миграцию и использовать в нужный момент.

## Применение миграций к базе данных

Как уже было упомянуто выше, для применения миграции к базе данных, существует команда `alembic upgrade head`.
В таком варианте ваша БД будет актуализирована до последней миграции, имеющейся в вашей директории с
миграциями, больше тут ничего знать не нужно.

Для того, чтобы откатить миграцию, существует команда `alembic downgrade <-№ вашей версии с конца>` в таком
случае alembic выполнит `downgrade` у `N` последних миграций.

Например, `alembic downgrade -2` отменит 2 последних миграции, в порядке их написания (по
идентификаторам `revision`).

## Конфликты и несколько "голов"

Если вы разрабываете не один, то наверняка рано или поздно возникнет ситуация, когда вы с коллегой в разных
ветках создадите миграции, идущие вслед за одной и той же версией. Всё будет хорошо, но после слияния этих
веток, просто так обновить БД до актуального состояния у вас не выйдет (ведь существуют 2 актуальные версии
миграций). Чтобы это исправить, нужно слить миграции точно так же, как вы слили код. Для этого есть
команда `alembic merge`. Если вы не уверены, то вы можете посмотреть список актуальных версий с помощью
команды `alembic heads` и вызвать `merge` с явным указанием ревизий
